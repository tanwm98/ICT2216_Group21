kirbysplunk.kirbychope.xyz {
    # Let Caddy auto-renew a real LE cert
    tls you@yourdomain.com

    # 1) HEC ingestion (no client auth here; Splunk still uses its token)
    @hec path /services/collector*
    handle @hec {
        reverse_proxy https://kirby-splunk:8088 {
            # tell Caddy to verify Splunkâ€™s cert as splunk-internal.kirbychope.xyz
            transport http {
                tls
                tls_server_name splunk-internal.kirbychope.xyz
		tls_trusted_ca_certs /etc/ssl/certs/splunk.crt
            }
        }
    }

    # 2) Splunk Web UI (everything else), protected by basic auth
    basicauth /* {
        admin $2a$14$f5v1c3eZMjd6/pLS55ymkuKdGM2ZcTx10F2ptet1Pryrj.I.1g47y
    }
    reverse_proxy http://kirby-splunk:8000
}


kirbychope.xyz {    
    @api path /api/*
    handle @api {
        reverse_proxy backend:3000
    }

    # Static assets
    @static path /static/* /js/* /css/* /images/*
    handle @static {
        root * /usr/share/caddy
        file_server
    }

    # Root redirect
    @root path /
    handle @root {
        root * /usr/share/caddy/public
        rewrite * /home.html
        file_server
    }

    # Try HTML files from multiple locations
    handle {
        # First try public folder
        root * /usr/share/caddy/public
        try_files {path}.html {path}
        file_server {
            pass_thru
        }

        # Then try html folder
        root * /usr/share/caddy/html
        try_files {path}.html {path}
        file_server {
            pass_thru
        }

        # Then try common folder
        root * /usr/share/caddy/common
        try_files {path}.html {path}
        file_server {
            pass_thru
        }

        # Finally fallback to backend
        reverse_proxy backend:3000
    }

    # Security headers
    header {
        X-Content-Type-Options nosniff
        X-Frame-Options SAMEORIGIN
    }
}
